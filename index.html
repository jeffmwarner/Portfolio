<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symptom Triage</title>
<link rel="stylesheet" type="text/css" href="/Portfolio/styles.css">
</head>
<h2>Try a Sample Mental Health Intake Prompt</h2>
<div>
  <textarea id="userInput" rows="4" placeholder="Tell me a bit about how you're feeling today..."></textarea>
  <br />
  <button id="sendRealBtn">Ask the assistant</button>
</div>
<pre id="realAssistantOutput" class="assistant-output"></pre>

<h2>Scripted Conversation Flow Demo</h2>
<p>
  This example shows a predetermined mental health intake flow with assistant and user messages.
</p>

<div id="scripted-chat" class="chat-container">
  <div id="chat-log"></div>

  <!-- Dynamic input area (text or choices appear here when needed) -->
  <div id="chat-input-area" class="chat-input-area">
    <!-- Filled by JS depending on the current step -->
  </div>
</div>


<script>
  const API_URL = "https://conversation-backend-yxsq.onrender.com/api/chat"; // my backend URL at Render

  document.getElementById("sendRealBtn").addEventListener("click", async () => {
    const inputEl = document.getElementById("userInput");
    const outputEl = document.getElementById("realAssistantOutput");
    const text = inputEl.value.trim();

    if (!text) {
      outputEl.textContent = "Please type something so I can send it to the assistant.";
      return;
    }

    outputEl.textContent = "Thinking...";

    try {
      const res = await fetch(API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ message: text })
      });

      if (!res.ok) {
        outputEl.textContent = "The assistant ran into a problem. Please try again later.";
        return;
      }

      const data = await res.json();

      const formatReply = (text) => {
        return text.replace(/([.?!])\s+/g, '$1\n\n');
      }
      
      outputEl.textContent = data.reply;
    } catch (err) {
      console.error(err);
      
      outputEl.textContent = "Network error talking to the assistant.";
    }
  });
</script>
    <script>
  // Predetermined conversation script
  // Types: "bot", "userInput", "choice"
const conversationScript = [
{
  type: "bot",
  text: "Hi, I'm here to help you get connected with care.",
},
{
  type: "userInput",
  id: "presentingConcern",
  text: "To start, what's the main thing you're hoping to get support with right now?",
},
{
  type: "bot",
  text: "Thank you for sharing that. That sounds really important.",
},
{
  type: "choice",
  id: "focusArea",
  text: "If you had to choise one area to focus on first, which feels most important?",
  choices: ["Managing anxiety or stress", "Sleep problems", "Depression"],
},
{
  type: "userInput",
  id: "button",
  text: "Got it! We'll keep that in mind as a starting point. {{focusArea}} is an important topic.",
},
];
  const XXXconversationScript = [
    {
      type: "bot",
      text: "Hi, I'm here to help you get connected with care. I'll ask a few quick questions to better understand what you need."
    },
    {
      type: "userInput",
      id: "presentingConcern",
      prompt: "To start, what’s the main thing you’re hoping to get support with right now?"
    },
    {
      type: "bot",
      text: (state) => {
        return `Thank you for sharing that. It sounds like you're dealing with: “${state.presentingConcern}”. That’s a lot to carry.`;
      }
    },
    {
      type: "choice",
      id: "focusArea",
      prompt: "If you had to choose one area to focus on first, which feels most important?",
      choices: [
        "Managing anxiety or stress",
        "Mood / depression",
        "Sleep problems",
        "Relationships and boundaries",
        "I’m not sure yet"
      ]
    },
    {
      type: "bot",
      text: (state) => {
        return `Got it. We'll keep “${state.focusArea}” in mind as a starting point.`;
      }
    },
    {
      type: "userInput",
      id: "timeline",
      prompt: "How long have you been dealing with this, roughly?"
    },
    {
      type: "bot",
      text: (state) => {
        return `Thanks. Knowing that this has been going on for about ${state.timeline} helps give context.`;
      }
    },
    {
      type: "choice",
      id: "nextStep",
      prompt: "What feels like the next most helpful step?",
      choices: [
        "Explore matching with a therapist",
        "Learn more about what therapy is like",
        "See coping strategies I can try on my own first"
      ]
    },
    {
      type: "bot",
      text: (state) => {
        if (state.nextStep.includes("matching")) {
          return "Great. Based on what you’ve shared, we’d guide you toward a therapist who has experience with similar concerns and preferences.";
        } else if (state.nextStep.includes("therapy is like")) {
          return "Totally fair. Many people want to understand what to expect before starting. We’d walk you through what sessions typically look like and how to find a good fit.";
        } else {
          return "That makes sense. Sometimes starting with small, concrete coping strategies can make the idea of therapy feel more approachable later.";
        }
      }
    },
    {
      type: "bot",
      text: "This is just a short demo, but this kind of flow can be extended into a full intake or guidance experience."
    }
  ];

  const chatLogEl = document.getElementById("chat-log");
  const chatInputAreaEl = document.getElementById("chat-input-area");

  let currentStepIndex = 0;
  const state = {}; // where we store user answers by id

function addBubble(text, role) {
  // Don’t render empty or whitespace-only messages
  if (text === undefined || text === null || !text.toString().trim()) {
    return;
  }

  const bubble = document.createElement("div");
  bubble.className = `chat-bubble ${role}`;
  bubble.textContent = text;
  chatLogEl.appendChild(bubble);
  chatLogEl.scrollTop = chatLogEl.scrollHeight;
}



function injectState(template, state) {
  if (typeof template !== "string") return template;

  return template.replace(/\{\{(\w+)\}\}/g, (_, key) => {
    return state[key] !== undefined ? state[key] : "";
  });
}

function NEWrenderStep() {
  chatInputAreaEl.innerHTML = ""; // clear previous input area

  if (currentStepIndex >= conversationScript.length) {
    // End of script
    return;
  }

  const step = conversationScript[currentStepIndex];

  if (step.type === "bot") {
    const raw = (typeof step.text === "function" ? step.text(state) : step.text);
    const text = injectState(raw, state);
    addBubble(text, "bot");
    currentStepIndex++;
    // Automatically move to next step after a short delay
    setTimeout(renderStep, 700);
  }

  else if (step.type === "userInput") {
    // Show prompt as bot, then show a textarea + submit
    const promptText = injectState(step.prompt || "", state);
    if (promptText.trim()) {
      addBubble(promptText, "bot");
    }

    const wrapper = document.createElement("div");

    const textarea = document.createElement("textarea");
    textarea.rows = 3;
    textarea.placeholder = "Type your response here...";

    const submitBtn = document.createElement("button");
    submitBtn.textContent = "Submit";
    submitBtn.className = "primary";

    submitBtn.addEventListener("click", () => {
      const value = textarea.value.trim();
      if (!value) return;

      // Add user bubble
      addBubble(value, "user");
      state[step.id] = value;

      // Clear input area and move to next step
      chatInputAreaEl.innerHTML = "";
      currentStepIndex++;
      renderStep();
    });

    wrapper.appendChild(textarea);
    wrapper.appendChild(submitBtn);
    chatInputAreaEl.appendChild(wrapper);
  }

  else if (step.type === "choice") {
    // Show prompt as bot, then buttons for choices
    const promptText = injectState(step.prompt || "", state);
    if (promptText.trim()) {
      addBubble(promptText, "bot");
    }

    const wrapper = document.createElement("div");
    wrapper.className = "choice-buttons";

    step.choices.forEach((choiceText) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.textContent = choiceText;

      btn.addEventListener("click", () => {
        // When a choice is clicked, show it as a user bubble
        addBubble(choiceText, "user");
        state[step.id] = choiceText;

        chatInputAreaEl.innerHTML = "";
        currentStepIndex++;
        renderStep();
      });

      wrapper.appendChild(btn);
    });

    chatInputAreaEl.appendChild(wrapper);
  }
}

        
  function renderStep() {
    chatInputAreaEl.innerHTML = ""; // clear previous input area

    if (currentStepIndex >= conversationScript.length) {
      // End of script
      return;
    }

    const step = conversationScript[currentStepIndex];

    if (step.type === "bot") {
      const text = typeof step.text === "function" ? step.text(state) : step.text;
      addBubble(text, "bot");
      currentStepIndex++;
      // Automatically move to next step after a short delay
      setTimeout(renderStep, 700);
    }

    else if (step.type === "userInput") {
      // Show prompt as bot, then show a textarea + submit
      addBubble(step.prompt, "bot");

      const wrapper = document.createElement("div");

      const textarea = document.createElement("textarea");
      textarea.rows = 3;
      textarea.placeholder = "Type your response here...";

      const submitBtn = document.createElement("button");
      submitBtn.textContent = "Submit";
      submitBtn.className = "primary";

      submitBtn.addEventListener("click", () => {
        const value = textarea.value.trim();
        if (!value) return;

        // Add user bubble
        addBubble(value, "user");
        state[step.id] = value;

        // Clear input area and move to next step
        chatInputAreaEl.innerHTML = "";
        currentStepIndex++;
        renderStep();
      });

      wrapper.appendChild(textarea);
      wrapper.appendChild(submitBtn);
      chatInputAreaEl.appendChild(wrapper);
    }

    else if (step.type === "choice") {
      // Show prompt as bot, then buttons for choices
      addBubble(step.prompt, "bot");

      const wrapper = document.createElement("div");
      wrapper.className = "choice-buttons";

      step.choices.forEach((choiceText) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = choiceText;

        btn.addEventListener("click", () => {
          // When a choice is clicked, show it as a user bubble
          addBubble(choiceText, "user");
          state[step.id] = choiceText;

          chatInputAreaEl.innerHTML = "";
          currentStepIndex++;
          renderStep();
        });

        wrapper.appendChild(btn);
      });

      chatInputAreaEl.appendChild(wrapper);
    }
  }

  // Kick off the scripted conversation when the page loads
  renderStep();
</script>


</html>
