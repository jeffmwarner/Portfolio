<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symptom Triage</title>
<link rel="stylesheet" type="text/css" href="/Portfolio/styles.css">
</head>
<!-- <h2>Try a Sample Mental Health Intake Prompt</h2>
<div>
  <textarea id="userInput" rows="4" placeholder="Tell me a bit about how you're feeling today..."></textarea>
  <br />
  <button id="sendRealBtn">Ask the assistant</button>
</div>
<pre id="realAssistantOutput" class="assistant-output"></pre> -->

<h2>Scripted Conversation Flow Demo</h2>
<p>
  This example shows a predetermined hypertension flow with assistant and user messages.
</p>

<div id="scripted-chat" class="chat-container">
  <div id="chat-log"></div>

  <!-- Dynamic input area (text or choices appear here when needed) -->
  <div id="chat-input-area" class="chat-input-area">
    <!-- Filled by JS depending on the current step -->
  </div>
</div>


<script>
  const API_URL = "https://conversation-backend-yxsq.onrender.com/api/chat"; // my backend URL at Render

  document.getElementById("sendRealBtn").addEventListener("click", async () => {
    const inputEl = document.getElementById("userInput");
    const outputEl = document.getElementById("realAssistantOutput");
    const text = inputEl.value.trim();

    if (!text) {
      outputEl.textContent = "Please type something so I can send it to the assistant.";
      return;
    }

    outputEl.textContent = "...";

    try {
      const res = await fetch(API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ message: text })
      });

      if (!res.ok) {
        outputEl.textContent = "The assistant ran into a problem. Please try again later.";
        return;
      }

      const data = await res.json();

      const formatReply = (text) => {
        return text.replace(/([.?!])\s+/g, '$1\n\n');
      }
      
      outputEl.textContent = data.reply;
    } catch (err) {
      console.error(err);
      
      outputEl.textContent = "Network error talking to the assistant.";
    }
  });
</script>
    <script>
  // Predetermined conversation script
  // Types: "bot", "userInput", "choice"
const conversationScript = [
  {"type": "bot", "text": "Hello! I'm your digital assistant, here to help with your recent hypertension (high blood pressure) diagnosis."},
  {"type": "bot", "text": "There's a lot of things to cover, and it can feel overwhelming..."},
  {"type": "bot", "text": "...but that's where we can help!"},
  {"type": "choice", "id": "focusArea", "prompt": "If you had to choose one area to focus on first, which feels most important?", "choices": ["Signs and symptoms", "Measuring blood pressure", "Medication concerns"]},
  {"type": "llmBot", "source": "focusArea"},
];



const ZZZconversationScript = [
  {"type": "bot", "text": "Hi, I'm here to help you get connected with care."},
  {"type": "llmInput", "id": "presentingConcern", "prompt": "To start, what's the main thing you're hoping to get support with right now?"},
  {"type": "choice", "id": "focusArea", "prompt": "If you had to choose one area to focus on first, which feels most important?", "choices": ["Managing anxiety or stress", "Sleep problems", "Depression"]},
  {"type": "choice", "id": "button", "prompt": "Got it! We'll keep that in mind as a starting point.","choices":["Thanks"]},
];
        
        
const YYYconversationScript = [
  {"type": "bot", "text": "Hi, I'm here to help you get connected with care."},
  {"type": "userInput", "id": "presentingConcern", "prompt": "To start, what's the main thing you're hoping to get support with right now?"},
  {"type": "bot", "text": "Thank you for sharing that. That sounds really important."},
  {"type": "choice", "id": "focusArea", "prompt": "If you had to choose one area to focus on first, which feels most important?", "choices": ["Managing anxiety or stress", "Sleep problems", "Depression"]},
  {"type": "userInput", "id": "button", "prompt": "Got it! We'll keep that in mind as a starting point. {{focusArea}} is an important topic."},
];
  const XXXconversationScript = [
    {
      type: "bot",
      text: "Hi, I'm here to help you get connected with care. I'll ask a few quick questions to better understand what you need."
    },
    {
      type: "userInput",
      id: "presentingConcern",
      prompt: "To start, what’s the main thing you’re hoping to get support with right now?"
    },
    {
      type: "bot",
      text: (state) => {
        return `Thank you for sharing that. It sounds like you're dealing with: “${state.presentingConcern}”. That’s a lot to carry.`;
      }
    },
    {
      type: "choice",
      id: "focusArea",
      prompt: "If you had to choose one area to focus on first, which feels most important?",
      choices: [
        "Managing anxiety or stress",
        "Mood / depression",
        "Sleep problems",
        "Relationships and boundaries",
        "I’m not sure yet"
      ]
    },
    {
      type: "bot",
      text: (state) => {
        return `Got it. We'll keep “${state.focusArea}” in mind as a starting point.`;
      }
    },
    {
      type: "userInput",
      id: "timeline",
      prompt: "How long have you been dealing with this, roughly?"
    },
    {
      type: "bot",
      text: (state) => {
        return `Thanks. Knowing that this has been going on for about ${state.timeline} helps give context.`;
      }
    },
    {
      type: "choice",
      id: "nextStep",
      prompt: "What feels like the next most helpful step?",
      choices: [
        "Explore matching with a therapist",
        "Learn more about what therapy is like",
        "See coping strategies I can try on my own first"
      ]
    },
    {
      type: "bot",
      text: (state) => {
        if (state.nextStep.includes("matching")) {
          return "Great. Based on what you’ve shared, we’d guide you toward a therapist who has experience with similar concerns and preferences.";
        } else if (state.nextStep.includes("therapy is like")) {
          return "Totally fair. Many people want to understand what to expect before starting. We’d walk you through what sessions typically look like and how to find a good fit.";
        } else {
          return "That makes sense. Sometimes starting with small, concrete coping strategies can make the idea of therapy feel more approachable later.";
        }
      }
    },
    {
      type: "bot",
      text: "This is just a short demo, but this kind of flow can be extended into a full intake or guidance experience."
    }
  ];

const chatLogEl = document.getElementById("chat-log");
  const chatInputAreaEl = document.getElementById("chat-input-area");

  let currentStepIndex = 0;
  const state = {}; // where we store user answers by id

  function addBubble(text, role) {
    const bubble = document.createElement("div");
    bubble.className = `chat-bubble ${role}`;
    bubble.textContent = text;
    chatLogEl.appendChild(bubble);
    chatLogEl.scrollTop = chatLogEl.scrollHeight;
  }

async function callLLM(userText) {
  const response = await fetch(`${API_URL}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ message: userText })
  });

  if (!response.ok) {
    console.error("LLM error:", await response.text());
    return "Sorry, I’m having trouble responding right now.";
  }

  const data = await response.json();
  // If your API returns { reply }, use data.reply
  return data.reply || data.summary || JSON.stringify(data);
}

        let typingEl = null;

function showTypingIndicator(text = "") {
  // Avoid duplicates
  if (typingEl) return;

  typingEl = document.createElement("div");
  typingEl.className = "chat-bubble bot"; // reuse your bot bubble styling
  typingEl.innerHTML = `
    <div class="typing-indicator">
      <span>${text}</span>
      <div class="typing-dots">
        <span></span><span></span><span></span>
      </div>
    </div>
  `;
  chatLogEl.appendChild(typingEl);
  chatLogEl.scrollTop = chatLogEl.scrollHeight;
}

function hideTypingIndicator() {
  if (typingEl && typingEl.parentNode) {
    typingEl.parentNode.removeChild(typingEl);
  }
  typingEl = null;
}


        
  function renderStep() {
    chatInputAreaEl.innerHTML = ""; // clear previous input area

    if (currentStepIndex >= conversationScript.length) {
      // End of script
      return;
    }

    const step = conversationScript[currentStepIndex];

    // if (step.type === "bot") {
    //   const text = typeof step.text === "function" ? step.text(state) : step.text;
    //   addBubble(text, "bot");
    //   currentStepIndex++;
    //   // Automatically move to next step after a short delay
    //   setTimeout(renderStep, 700);
    // }
      if (step.type === "bot") {
  const raw = (typeof step.text === "function" ? step.text(state) : step.text);
  //const text = injectState ? injectState(raw, state) : raw; // if you’re using injectState

  showTypingIndicator();
  chatInputAreaEl.innerHTML = "";

  setTimeout(() => {
    hideTypingIndicator();
    addBubble(raw, "bot");
    currentStepIndex++;
    setTimeout(renderStep, 500);
  }, 500); // 0.5s “thinking”
}

    else if (step.type === "userInput") {
      // Show prompt as bot, then show a textarea + submit
      addBubble(step.prompt, "bot");

      const wrapper = document.createElement("div");

      const textarea = document.createElement("textarea");
      textarea.rows = 3;
      textarea.placeholder = "Type your response here...";

      const submitBtn = document.createElement("button");
      submitBtn.textContent = "Submit";
      submitBtn.className = "primary";

      submitBtn.addEventListener("click", () => {
        const value = textarea.value.trim();
        if (!value) return;

        // Add user bubble
        addBubble(value, "user");
        state[step.id] = value;

        // Clear input area and move to next step
        chatInputAreaEl.innerHTML = "";
        currentStepIndex++;
        renderStep();
      });

      wrapper.appendChild(textarea);
      wrapper.appendChild(submitBtn);
      chatInputAreaEl.appendChild(wrapper);
    }

    else if (step.type === "choice") {
      // Show prompt as bot, then buttons for choices
      addBubble(step.prompt, "bot");

      const wrapper = document.createElement("div");
      wrapper.className = "choice-buttons";

      step.choices.forEach((choiceText) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = choiceText;

        btn.addEventListener("click", () => {
          // When a choice is clicked, show it as a user bubble
          addBubble(choiceText, "user");
          state[step.id] = choiceText;

          chatInputAreaEl.innerHTML = "";
          currentStepIndex++;
          renderStep();
        });

        wrapper.appendChild(btn);
      });

      chatInputAreaEl.appendChild(wrapper);
    }
      else if (step.type === "llmInput") {
  // Show prompt as bot
  addBubble(step.prompt, "bot");

  const wrapper = document.createElement("div");

  const textarea = document.createElement("textarea");
  textarea.rows = 3;
  textarea.placeholder = "Type your response here...";

  const submitBtn = document.createElement("button");
  submitBtn.textContent = "Submit";
  submitBtn.className = "primary";
  /*  below is new to next comment*/
  submitBtn.addEventListener("click", async () => {
  const value = textarea.value.trim();
  if (!value) return;

  addBubble(value, "user");
  state[step.id] = value;
  chatInputAreaEl.innerHTML = "";

  showTypingIndicator("Thinking about your response…");

  const llmReply = await callLLM(value, step.endpoint);

  hideTypingIndicator();
  addBubble(llmReply, "bot");

  currentStepIndex++;
  renderStep();
});

  // submitBtn.addEventListener("click", async () => {
  //   const value = textarea.value.trim();
  //   if (!value) return;

  //   addBubble(value, "user");
  //   state[step.id] = value;

  //   chatInputAreaEl.innerHTML = "";

  //   //  Call the model dynamically
  //   const llmReply = await callLLM(value);

  //   addBubble(llmReply, "bot");

  //   currentStepIndex++;
  //   renderStep();
  // });

  wrapper.appendChild(textarea);
  wrapper.appendChild(submitBtn);
  chatInputAreaEl.appendChild(wrapper);
}
else if (step.type === "llmBot") {
  const sourceId = step.source;
  const inputText = state[sourceId];

  if (!inputText) {
    addBubble("I don’t have enough information yet to respond.", "bot");
    currentStepIndex++;
    setTimeout(renderStep, 500);
    return;
  }

  chatInputAreaEl.innerHTML = "";
  showTypingIndicator();

  (async () => {
    const llmReply = await callLLM(inputText, step.endpoint);
    hideTypingIndicator();

    addBubble(llmReply, "bot");

    if (step.id) {
      state[step.id] = llmReply;
    }

    currentStepIndex++;
    renderStep();
  })();
}

    
  }


        
  // Kick off the scripted conversation when the page loads
  renderStep();
</script>


</html>
